- gdbでのデバッグ方法
https://blog.rkarsnk.jp/post/2021/12/10/debugefiapp/

- largeのアプリケーションをメモリ上にロードするタイミングでPage Fault
    - セクションのサイズが大きいとmemsetのところで発生している。
    - 3 * 1024 * 1024 / (4096) = 3 * 256 ページ。pml4を変更するレベルの大きさのページは取っていないはずだが
    - グローバル変数の配列のサイズを小さくすると解消（3 * 1024とか）
    - Loadセクションのロード用に作っておくページ数の計算に不具合があり、そこを直したら解消した。
        - 本やコードだと、`phdr[i].p_memsz`のメモリサイズだけから、ページ数を計算しているが、
        `phdr[i].p_vaddr`が必ずしもページの開始アドレスから始まるわけではないので、`phdr[i].p_vaddr`とページ開始アドレスとの差分も考慮する必要がある。
        - 考慮しないと、差分のサイズ分、終端メモリの0セットなどする際に、メモリ確保していない隣接ページにアクセスしてしまう。
        - memcpyやmemsetは仮想アドレスをもとにメモリコピーをするようで、物理メモリがページとして断片的にあるような状態でも
        問題なくコピーできているようだった。

    - 正しいメモリ計算
    ```
    Elf64_Xword page_start_offset = (reinterpret_cast<Elf64_Xword>(phdr[i].p_vaddr) & 0xfff);
    const auto num_4kpages = (phdr[i].p_memsz + page_start_offset + 4095) / 4096;
    ```

    - day19で生じていた標準ライブラリのatolを使用するとクラッシュする不具合の原因でもあった
        - 標準ライブラリ使ったバージョンだと、オフセットとページの開始アドレスとの差分が大きなセクションがあった。
        - オリジナルのosbook_day19aで修正した結果、atolを使用したバージョンでも無事に動いた。

- コマンドを実行するタイミングでPage Fault
    - ~~rpnではRIPが0, RSPがfffffffffffff000とおかしな値になっている。~~
    - ~~largeもRIPがffff80000000164, RSPがffffffffffffeff0とずれた値になっている。~~
    - ↑ gdbでデバッグした限り、ちゃんと各アプリのmainに移動して、処理を実行できているようには見える。
    - CallAppに渡す引数では正しいアドレスを渡せているように見える。
    - 問題として、while(1)で止まらず、更にRIPが進んでしまい、未定義の場所をアクセスしようとしてしまったり、
    入るはずのない分岐に入ってreturnしてしまったりしているようだった。
    - この記事を見て`while(1);`を修正したら、想定した挙動になった。未定義動作になっていたっぽい...
    https://qiita.com/tkmtSo/items/de3148dd1dcb70f38d6a

- リスト20.25で書いているsyscallの書き込むセグメントレジスタの値（セグメントレジスタの読み方はp.462）
    - CS: 000000000001000
        - インデックスは1, RPLは0（カーネル権限）
    - SS: 000000000010000 (CS + 8)
        - インデックスは2, RPLは0（カーネル権限）
- sysretの書き込むセグメントレジスタの値
    - CS: 000000000100011 ((16 | 3) + 16)
        - インデックスは4, RPLは3（アプリ権限）
    - SS: 000000000011011 ((16 | 3) + 8)
        - インデックスは3, RPLは0（アプリ権限）
- sysretのCSやSSの順、逆にならない？って思ったら、セグメントの番号設定も変えるとのことだった。

- syscall.cppでシステムコール番号と関数との対応があり、あとは以下のような順でシステムコールが呼び出されている。
    1. rpn.cppにexternされているSyscallLogString関数
    2. rpn/syscall.asmにあるSyscallLogStringでシステムコール番号をeaxレジスタに指定しつつ、syscall呼び出し。
    3. MSR（モデル固有レジスタ）に登録された、asmfunc.asmにあるSyscallEntryが呼び出され、eaxレジスタにある番号に対応するシステムコール関数を
    syscall.cppで定義したsyscall_tableから引っ張り出して、システムコールを呼び出している。
    4. システムコールの処理が終わると、sysretでもとのアプリ権限で処理を実行している状態に戻る。
