- gdbでのデバッグ方法
https://blog.rkarsnk.jp/post/2021/12/10/debugefiapp/

- largeのアプリケーションをメモリ上にロードするタイミングでPage Fault
    - セクションのサイズが大きいとmemsetのところで発生している。
    - 3 * 1024 * 1024 / (4096) = 3 * 256 ページ。pml4を変更するレベルの大きさのページは取っていないはずだが
    - グローバル変数の配列のサイズを小さくすると解消（3 * 1024とか）
    - Loadセクションのロード用に作っておくページ数の計算に不具合があり、そこを直したら解消した。
        - 本やコードだと、`phdr[i].p_memsz`のメモリサイズだけから、ページ数を計算しているが、
        `phdr[i].p_vaddr`が必ずしもページの開始アドレスから始まるわけではないので、`phdr[i].p_vaddr`とページ開始アドレスとの差分も考慮する必要がある。
        - 考慮しないと、差分のサイズ分、終端メモリの0セットなどする際に、メモリ確保していない隣接ページにアクセスしてしまう。
        - memcpyやmemsetは仮想アドレスをもとにメモリコピーをするようで、物理メモリがページとして断片的にあるような状態でも
        問題なくコピーできているようだった。

    - 正しいメモリ計算
    ```
    Elf64_Xword page_start_offset = (reinterpret_cast<Elf64_Xword>(phdr[i].p_vaddr) & 0xfff);
    const auto num_4kpages = (phdr[i].p_memsz + page_start_offset + 4095) / 4096;
    ```

    - day19で生じていた標準ライブラリのatolを使用するとクラッシュする不具合の原因でもあった
        - 標準ライブラリ使ったバージョンだと、オフセットとページの開始アドレスとの差分が大きなセクションがあった。
        - オリジナルのosbook_day19aで修正した結果、atolを使用したバージョンでも無事に動いた。

- コマンドを実行するタイミングでPage Fault
    - ~~rpnではRIPが0, RSPがfffffffffffff000とおかしな値になっている。~~
    - ~~largeもRIPがffff80000000164, RSPがffffffffffffeff0とずれた値になっている。~~
    - ↑ gdbでデバッグした限り、ちゃんと各アプリのmainに移動して、処理を実行できているようには見える。
    - CallAppに渡す引数では正しいアドレスを渡せているように見える。
    - 問題として、while(1)で止まらず、更にRIPが進んでしまい、未定義の場所をアクセスしようとしてしまったり、
    入るはずのない分岐に入ってreturnしてしまったりしているようだった。
    